---
title: "MIPS Instruction Set Architecture"
publishDate: "20th February 2024"
---

# Instruction Set Architectures

### Programs, Instructions and Instruction sets

To get a task done in a computer, you require the following: `a computer itself`, `data`, and a `program.` A computer program is a set of instructions that helps achieve the completion of a task. That's the highest form of abstraction you can get.

Words in a computer's language are what we call `Instructions`. An instruction can be considered the smallest piece of work to be done by a computer. The computer's vocabulary is its `Instruction Set`. Computer instructions both indicate the operation to do and the operands to be operated on. Computer Instructions are encoded into binary as `Machine Language`. Didn't click? Might want to read the paragraph again.

The instruction sets of different architectures are more like different dialects than different languages. Almost all architectures define basic instructions, such as add, subtract, and jump, that operate on memory or registers. Once you have learned one instruction set, understanding others is fairly straightforward.

## Elements of an Instruction

The elements of an instruction consists of the following:

- Opcode (Operation Code): Specifics the operation to be performed by the computer.
- Source Operand: Inputs for the operation; you could have one or more sources for an operation.
- Result Operand: Operation may want to store results after an operation.
- Next Instruction Reference: Tells the processor where to fetch the next instruction.

### Operands: Registers, Memory, and Constants

An instruction operates on operands. In the snippet below, the variables a, b, and c are all operands. But computers operate on 1's and 0's, not  variable names. The instructions need a physical location from which to  retrieve the binary data.

```assembly
High-Level Code
a = b + c;

MIPS Assembly Code
add a, b, c
```

Operands can be stored in registers or memory,  or they may be constants stored in the instruction itself. Computers use various locations to hold operands in order to optimize for speed and  data capacity. Operands stored as constants or in registers are accessed quickly, but they hold only a small amount of data. Additional data must be accessed from memory, which is large but slow.

The MIPS architecture uses 32 registers, called the `register set` or `register file`.

#### The MIPS Register File

<img src="/register-file.png"/> 

If we were only to use registers to store program we would only be allowed 32 slots which for some programs, it wouldn't be very efficient and effective. That's why we use the Memory too.

When compared to the register file, memory has many data locations, but accessing it takes a longer amount of time.

By using a combination of memory and registers, a program can access a large amount of data fairly quickly. Memories are organized as an array of data words. MIPS uses a `byte-addressable memory`. This means that the smallest unit of memory data we can retrieve is 8 bits or a byte. That is, each byte in memory has a unique address. However, for explanation purposes only, we first introduce `a word-addressable memory` (can be any size depending on the architecture of the processor), and afterward describe the MIPS byte-addressable memory.

**Word Addressable Memory:**
The diagram below shows a memory array that is word-addressable. That is, each 32-bit data word has a unique 32-bit address. Both the 32-bit word address and the 32-bit data value are written in hexadecimal.

For example, data `0xF2F1AC07` is stored at memory address `00000001`.

<img src="word-addr.png"/>

**Byte Addressable Memory:**
The diagram below shows how to read and write words in the MIPS byte-addressable memory. The word address is four times the word number. The MIPS assembly code reads words 0, 2, and 3 and writes words 1, 8, and 100. The offset can be written in decimal or hexadecimal.

Byte-addressable memories are organized in a `big-endian` or `little-endian` fashion.
<img src="byte-addr.png"/>

```assembly
MIPS Assembly Code
lw $s0, 0($0)    # read data word 0 (0xABCDEF78) into $s0
lw $s1, 8($0)    # read data word 2 (0x01EE2842) into $s1
lw $s2, OxC($0)  # read data word 3 (0x40F30788) into $s2
sw $s3, 4($0)    # write $s3 to data word 1
sw $s4, 0x20($0) # write $s4 to data word 8
sw $s5, 400($0)  # write $s5 to data word 100
```

We do a lot of memory addressing with offsets and a base address by orders of 4. We can use  the decimal or hexadecimal for the offset value.

Constants and Immediate Operands. The immediate specified in an instruction is a 16-bit two's comple-ment number in the range [-32,768, 32,767]. Which is $[-2^{15}, 2^{15}]$ in terms of bit size width.

## Instruction Formats

MIPS makes the compromise of defining three instruction formats: **R-type**, **I-type**, and **J-type**. This small number of formats allows for some regularity among all the types, and thus simpler hardware, while also accommodating different instruction needs, such as the need to encode large constants in the instruction. R-type instructions operate on `three registers`. I-type instructions operate on`two registers and a 16-bit immediate`. J-type (jump) instructions operate on `one 26-bit immediate`.

### Types of CPU Organization

Most computers fall under three types of CPU organization:

- Single Accumulator Organization (Earlier Von Neumann)
- General Register Organization
- Stack Organization

### Different types of Instruction Format

#### Register-type Instructions

The name R-type is short for register-type. R-type instructions use three registers as operands: two as sources, and one as a destination. The 32-bit instruction has six fields: op, rs, rt, rd, shamt, and funct. Each field is five or six bits, as indicated in the diagram below.
<img src="r-type.png"/>

- The operation the instruction performs is encoded in the two fields highlighted in blue: op (also called opcode or operation code) and funct (also called the function).

> [!NOTE] Note for Opcode and Funct for R-type:
> All R-type instructions have an opcode of 0.
> The specific R-type operation is determined by the funct field.
> For example, the opcode and funct fields for the add instruction are 0 (0000002) and 32 (1000002), respectively. Similarly, the sub instruction has an opcode and funct field of 0 and 34.

- The operands are encoded in the three fields: rs, rt, and rd. The first two registers, rs and rt, are the source registers; rd is the destination.
- The fifth field, shamt, is used only in shift operations. In those instructions, the binary value stored in the 5-bit shamt field indicates the amount to shift. For all other R-type instructions, shamt is 0.

How the bits are arranged in a mips r-type instruction issued.
<img src="r-type_mips.png"/>

#### Immediate-type Instructions

The name I-type is short for immediate-type. I-type instructions use two register operands and one immediate operand.

The 32-bit instruction has four fields: op, rs, rt, and imm. The first three fields, op, rs, and rt, are like those of R-type instructions. The imm field holds the 16-bit immediate.

<img src="i-type.png"/>

The operation is determined solely by the opcode, highlighted in blue. The operands are specified in the three fields rs, rt, and imm.

rs and imm are always used as source operands. rt is used as a destination for some instructions (such as addi and lw) but as another source for others (such as sw).

<img src="i-types_mips.png"/>

I-type instructions have a 16-bit immediate field, but the immediates are used in 32-bit operations. For example, lw adds a 16-bit offset to a 32-bit base register.
> [!NOTE] What should go in the upper half of the 32 bits?
> For positive immediates, the upper half should be all 0's, but for negative immediates, the upper half should be all 1's.
> An exception to this rule is that logical operations (andi, ori, xori) place 0's in the upper half; this is called zero extension rather than sign extension.

#### J-type Instructions

The name J-type is short for jump-type. This format is used only with jump instructions. This instruction format uses a single 26-bit address operand, addr, as shown in the diagram below.
<img src="j-type.png"/>

### Interpreting Machine Language Code

To interpret machine language, one must decipher the fields of each 32-bit instruction word. Different instructions use different formats, but all formats start with a 6-bit opcode field. Thus, the best place to begin is to look at the opcode. If it is 0, the instruction is R-type; otherwise it is I-type or J-type.

### Addressing Modes

MIPS uses five addressing modes: register-only, immediate, base, PC-relative, and pseudo-direct. The first three modes (register-only, immediate, and base addressing) define modes of reading and writing operands. The last two (PC-relative and pseudo-direct addressing) define modes of writing the program counter, PC.

- Implied/Implicit Addressing
  - No address field is specified.
  - The operand is specified in the instruction implicitly.
  - Works on the accumulator. CLA; to clear the accumulator, CMA; to complement the contents of the accumulator all use implicit addressing.
- Immediate Addressing
  - The required operand is present in the instruction.
  - Usually used to set initial values and set constants.
  - The size of data is always restrictive to the size of the address field.
- Direct Addressing
  - Contains the effective address of the operand in memory.
- Indirect Addressing:
  - The operands contain an address where the address of the data is present. The instruction would contain information about where the address of the data accessed is present in the same memory.
  - Reference to the address of a word in memory (could be useful as pointers in C)
  - For a word of length $N$, an address space of $2^N$ is now which resolves the limitation of direct addressing.
- Register Addressing:
  - Register-only addressing uses registers for all source and destination operands. All R-type instructions use register-only addressing.
- Register Indirect Addressing:
  - Analogous to the indirect addressing, but in this case, a register to hold the address of the next register or memory space that contains the actual data for the operation.
- Displacement Addressing:
  - Relative Addressing:
    - Use PC-relative addressing to specify the new value of the PC if data needs to be accessed.
    - The signed offset in the immediate field is added to the PC to obtain the new PC; hence, the branch destination address is said to be relative to the current PC.
  - Base Register Addressing:
    - Uses a base register and an offset or displacement value.
    - In this addressing mode, the effective memory address is calculated by adding the value stored in a base register to a constant offset or displacement value provided in the instruction.
  - Indexed Addressing:
    - The CPU has a special register that has an index value.
    - The address field would reference the main memory and the index value from the index special register and that would serve as the displacement value for accessing the data we need.
    - The index register can undergo automatically increment and decrement after it gets referenced, and that could be useful for other operations as well.
  - Stack Addressing:
    - A stack is a linear array of locations.
    - Items are appended at the top of the stack so that the blocks are partially filled.
    - It has a stack pointer (register) that references stack locations in memory that are also register indirect addresses.

## Instruction Cycle

The instruction cycle consists of the following cycle steps:

1. Fetch the Instruction from memory
2. Decode the instruction
3. Read the required operand
4. Entertain an interrupt if it is generated
5. Execute the instruction.

Instruction Flow Diagram.

<img src="instruction-flow.png"/>

To be continued!